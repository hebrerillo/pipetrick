==6822== Helgrind, a thread error detector
==6822== Copyright (C) 2007-2017, and GNU GPL'd, by OpenWorks LLP et al.
==6822== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info
==6822== Command: ./test --gtest_break_on_failure --gtest_filter=PipeTrickTest.WhenConnectingALotOfClientsWithAHighTimeOutToOneServerAndStoppingOnlyTheServer_ThenTheQuitProcessIsFast
==6822== 
==6822== ---Thread-Announcement------------------------------------------
==6822== 
==6822== Thread #1 is the program's root thread
==6822== 
==6822== ----------------------------------------------------------------
==6822== 
==6822== Thread #1: pthread_cond_{signal,broadcast}: associated lock is not held by calling thread
==6822==    at 0x4844CB6: pthread_cond_signal_WRK (hg_intercepts.c:1565)
==6822==    by 0x4848D56: pthread_cond_signal@* (hg_intercepts.c:1586)
==6822==    by 0x4A7893F: __pthread_cond_wait_common (pthread_cond_wait.c:536)
==6822==    by 0x4A7893F: pthread_cond_timedwait@@GLIBC_2.3.2 (pthread_cond_wait.c:665)
==6822==    by 0x4847AA1: pthread_cond_timedwait_WRK (hg_intercepts.c:1387)
==6822==    by 0x4848D32: pthread_cond_timedwait@* (hg_intercepts.c:1422)
==6822==    by 0x11D32D: __gthread_cond_timedwait(pthread_cond_t*, pthread_mutex_t*, timespec const*) (gthr-default.h:872)
==6822==    by 0x11EACD: std::cv_status std::condition_variable::__wait_until_impl<std::chrono::duration<long, std::ratio<1l, 1000000000l> > >(std::unique_lock<std::mutex>&, std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long, std::ratio<1l, 1000000000l> > > const&) (condition_variable:188)
==6822==    by 0x11E627: std::cv_status std::condition_variable::wait_until<std::chrono::_V2::steady_clock, std::chrono::duration<long, std::ratio<1l, 1000000000l> > >(std::unique_lock<std::mutex>&, std::chrono::time_point<std::chrono::_V2::steady_clock, std::chrono::duration<long, std::ratio<1l, 1000000000l> > > const&) (condition_variable:121)
==6822==    by 0x11D139: bool std::condition_variable::wait_until<std::chrono::_V2::steady_clock, std::chrono::duration<long, std::ratio<1l, 1000000000l> >, pipetrick::Server::waitForRunningThread()::{lambda()#1}>(std::unique_lock<std::mutex>&, std::chrono::time_point<std::chrono::_V2::steady_clock, std::chrono::duration<long, std::ratio<1l, 1000000000l> > > const&, pipetrick::Server::waitForRunningThread()::{lambda()#1}) (condition_variable:138)
==6822==    by 0x11CFD2: bool std::condition_variable::wait_for<long, std::ratio<1l, 1000l>, pipetrick::Server::waitForRunningThread()::{lambda()#1}>(std::unique_lock<std::mutex>&, std::chrono::duration<long, std::ratio<1l, 1000l> > const&, pipetrick::Server::waitForRunningThread()::{lambda()#1}) (condition_variable:166)
==6822==    by 0x11C26E: pipetrick::Server::waitForRunningThread() (server.cpp:220)
==6822==    by 0x11C1B7: pipetrick::Server::stop() (server.cpp:205)
==6822== 
==6822== 
==6822== Use --history-level=approx or =none to gain increased speed, at
==6822== the cost of reduced accuracy of conflicting-access information
==6822== For lists of detected and suppressed errors, rerun with: -s
==6822== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 11942 from 41)
