diff --git a/common.h b/common.h
index 9832020..aaab385 100644
--- a/common.h
+++ b/common.h
@@ -41,7 +41,6 @@ public:
      *
      * @param[out] socketDescriptor The new socket descriptor.
      * @param[in] Additional flags to the 'socket' call.
-     * @param[in] prefix
      * @return true if the socket was created successfully, false if the 'socket' call failed.
      */
     static bool createSocket(int& socketDescriptor, int flags = 0, const std::string& prefix = "");
diff --git a/server.cpp b/server.cpp
index e6e2337..88de41d 100644
--- a/server.cpp
+++ b/server.cpp
@@ -1,3 +1,4 @@
+#include <sys/ioctl.h>
 #include "server.h"
 #include "log.h"
 
@@ -19,23 +20,55 @@ void Server::closeClientAndNotify(int socketClientDescriptor)
     clientsCV_.notify_all();
 }
 
-bool Server::sleep(char clientBuffer[BUFFER_SIZE])
+bool Server::sleep(int socketClientDescriptor, char clientBuffer[BUFFER_SIZE])
 {
     int sleepingTime = atoi(clientBuffer);
-    std::unique_lock < std::mutex > lock(mutex_);
-    if (quitSignal_)
+    std::chrono::microseconds selectTimeOut(sleepingTime * 1000);
+    fd_set readFds;
+    FD_ZERO(&readFds);
+    FD_SET(socketClientDescriptor, &readFds);
+    FD_SET(pipeDescriptors_[0], &readFds);
+
+    SelectResult result = Common::doSelect((pipeDescriptors_[0] > socketClientDescriptor ? pipeDescriptors_[0] : socketClientDescriptor) + 1, &readFds, nullptr, &selectTimeOut, "Server:");
+    if (result == SelectResult::TIMEOUT)
+    {
+        strcpy(clientBuffer, std::to_string(++sleepingTime).c_str());
+        return false;
+    }
+
+    if (result == SelectResult::ERROR)
     {
-        Log::logVerbose("Server::sleep - Quit signal already raised, not sleeping.");
+        Log::logError("Server::sleep - Select call failed.");
         return true;
     }
 
-    clientsCV_.wait_for(lock, std::chrono::milliseconds(sleepingTime), [this]()
+    if (FD_ISSET(pipeDescriptors_[0], &readFds))
     {
-        return quitSignal_;
-    });
+        Log::logVerbose("Server::sleep - stop was called while sleeping.");
+        return true;
+    }
 
-    strcpy(clientBuffer, std::to_string(++sleepingTime).c_str());
-    return quitSignal_;
+    if (!FD_ISSET(socketClientDescriptor, &readFds))
+    {
+        Log::logError("Server::sleep - select returned with no error, no files ready to be read and before the sleeping time!!!");
+        return true;
+    }
+
+    //Let's check if the remote peer closed the connection
+    int bytesAvailable;
+    if (ioctl(socketClientDescriptor, FIONREAD, &bytesAvailable) == -1)
+    {
+        int errorNumber = errno;
+        Log::logError("Server::sleep - ioctel failed when checking if the remote peer closed the connection", errorNumber);
+        return true;
+    }
+
+    if (bytesAvailable == 0) //The remote peer closed the connection.
+    {
+        Log::logVerbose("Server::sleep - the remote peer closed the connection.");
+    }
+
+    return true;
 }
 
 void Server::runClient(int socketClientDescriptor)
@@ -77,7 +110,7 @@ void Server::runClient(int socketClientDescriptor)
         return;
     }
 
-    if (sleep(clientBuffer))
+    if (sleep(socketClientDescriptor, clientBuffer))
     {
         Log::logVerbose("Server::runClient - Client will be closed after the sleeping time. No writing back to them.");
         closeClientAndNotify(socketClientDescriptor);
diff --git a/server.h b/server.h
index cea299a..e161e27 100644
--- a/server.h
+++ b/server.h
@@ -91,12 +91,13 @@ private:
 
     /**
      * Place the current thread to sleep for a specific number of milliseconds, which is specified in 'buffer'. However, the call will return immediately if 'quitSignal_' is raised from
-     * another thread. It also modifies 'buffer' by increasing the initial number of milliseconds by one.
+     * another thread or if the remote client closes the connection. It also modifies 'buffer' by increasing the initial number of milliseconds by one.
      *
+     * @param[in] The socket descriptor of the remote client.
      * @param[in/out] buffer The string containing the number of milliseconds to sleep. After the call, this number will be increased by one.
-     * @return true if 'quitSignal_' was raised while sleeping, false if the current thread was capable of sleeping for the time specified in 'buffer'.
+     * @return true if 'stop' call was performed while sleeping or the peer closed the connection, false if the current thread was capable of sleeping for the time specified in 'buffer'.
      */
-    bool sleep(char buffer[BUFFER_SIZE]);
+    bool sleep(int socketClientDescriptor, char buffer[BUFFER_SIZE]);
 
     /**
      * Raises the flag 'quitSignal_' and writes to the 'write' end of the pipe (pipeDescriptor_[1]).
diff --git a/test.cpp b/test.cpp
index 303afab..942cc6d 100644
--- a/test.cpp
+++ b/test.cpp
@@ -107,6 +107,27 @@ TEST_F(PipeTrickTest, WhenAddingSomeClientsWithDifferentSleepingTimes_ThenTheSer
     server.stop();
 }
 
+TEST_F(PipeTrickTest, WhenAddingSomeClientsWithDifferentSleepingTimes_ThenTheServerReturnsTheCorrectIncreasedSleepingTimeForEachClient2)
+{
+    size_t const MAX_NUMBER_CLIENTS = 1;
+    Server server(MAX_NUMBER_CLIENTS);
+    server.start();
+
+    Client c1;
+    std::thread threadFirstClient = std::thread([&c1]()
+    {
+        std::chrono::milliseconds serverDelay(90 * 1000);
+        EXPECT_FALSE(c1.sendDelayToServerAndWait(serverDelay));
+    });
+    
+    std::this_thread::sleep_for(std::chrono::milliseconds(180));
+    EXPECT_EQ(server.getNumberOfClients(), MAX_NUMBER_CLIENTS);
+    c1.stop();
+    std::this_thread::sleep_for(std::chrono::milliseconds(280));
+    EXPECT_EQ(server.getNumberOfClients(), 0);
+    threadFirstClient.join();
+    server.stop();
+}
 
 int main(int argc, char **argv)
 {
